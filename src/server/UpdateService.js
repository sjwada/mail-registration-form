/**
 * UpdateService (Application Layer)
 * 
 * Orchestrates the "Update Household" use case.
 * - Change Detection (TODO)
 * - Data Persistence (Versioning)
 * - Notifications (TODO)
 */
// const { HouseholdRepositoryClean } = require('./domain/repository/HouseholdRepositoryClean');
// const { Result } = require('./shared/Result');

class UpdateService {
  constructor(householdRepo) {
    this.householdRepo = householdRepo || new HouseholdRepositoryClean();
  }

  /**
   * Update household data.
   * @param {object} formData (DTO from frontend)
   * @returns {Result<object, Error>}
   */
  update(formData) {
    // 0. Filter Empty Entries
    formData.guardians = formData.guardians.filter(g => g.lastName && g.firstName);
    formData.students = formData.students.filter(s => s.lastName && s.firstName);

    // 1. Validate
    return ValidationService.validate(formData)
      .flatMap(() => {
        // 2. Fetch Current Data to check for changes
        if (formData.household && formData.household.householdId) {
          return this.householdRepo.getHouseholdData(formData.household.householdId)
            .flatMap(currentData => {
               if (!this._isDataChanged(currentData, formData)) {
                 // No changes detected - return early success
                 return Result.ok({
                   success: true,
                   message: '変更がないため、保存をスキップしました。',
                   householdId: formData.household.householdId,
                   version: currentData.household.currentVersion, 
                   householdData: currentData
                 });
               }
               
               // Changes exist, proceed to save
               return this._performSave(formData);
            });
        }

        // New Registration or ID missing (should not happen in UpdateService but fallback)
        return this._performSave(formData);
      });
  }

  /**
   * Internal save logic
   */
  _performSave(formData) {
    return this.householdRepo.save(formData)
       .map(result => {
           // Success
           
           // Send Notification Email (Side Effect)
           try {
             // Use current time as approximation of update time
             sendEditNotificationEmails(formData.guardians, new Date());
           } catch (e) {
             console.error("Failed to send email: " + e.toString());
             // Suppress email error to ensure save success is returned
           }

           return {
               householdId: result.householdId,
               version: result.version
           };
       })
       .flatMap(ctx => {
           // Fetch the fully persisted updated data
           return this.householdRepo.getHouseholdData(ctx.householdId)
             .map(fullData => {
                 return {
                     success: true,
                     message: '修正内容を保存しました。',
                     householdId: ctx.householdId,
                     version: ctx.version,
                     householdData: fullData
                 };
             });
       });
  }

  /**
   * Compare current persistent data with incoming form data
   * @param {object} current 
   * @param {object} incoming 
   * @returns {boolean} true if meaningful changes exist
   */
  _isDataChanged(current, incoming) {
    // Helper to normalize objects for comparison
    // 1. Remove metadata (IDs generated by system if not in form, timestamps, etc)
    // 2. Convert null/undefined to empty string
    
    const normalize = (obj) => {
      // Simple deep clone
      return JSON.parse(JSON.stringify(obj, (key, value) => {
        // Exclude system fields
        if (['version', 'updatedAt', 'createdAt', 'currentVersion', 'history'].includes(key)) return undefined;
        // Treat null/undefined as empty string for value comparison
        if (value === null || value === undefined) return '';
        return value;
      }));
    };

    // We can't just compare root objects because structure might differ slightly.
    // Compare core lists.
    
    // Household (Exclude notes? No, notes are editable)
    const h1 = normalize(current.household);
    const h2 = normalize(incoming.household);
    // Ensure householdId is same (it is)
    
    // Guardians
    // Incoming might not have guardianId for new ones, but current does.
    // If ANY field differs, it's a change.
    // Array length check
    if (current.guardians.length !== incoming.guardians.length) return true;
    if (current.students.length !== incoming.students.length) return true;

    // Deep compare normalized 
    return JSON.stringify(h1) !== JSON.stringify(h2) ||
           JSON.stringify(normalize(current.guardians)) !== JSON.stringify(normalize(incoming.guardians)) ||
           JSON.stringify(normalize(current.students)) !== JSON.stringify(normalize(incoming.students));
  }
}

if (typeof exports !== 'undefined') {
  exports.UpdateService = UpdateService;
}
